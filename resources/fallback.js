/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./lib/fallback.js":
/*!*************************!*\
  !*** ./lib/fallback.js ***!
  \*************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval("const URLCompressor = __webpack_require__(/*! ./url-comp.js */ \"./lib/url-comp.js\");\n\nconst queryString = new URLSearchParams(window.location.search);\nconst host = queryString.get(\"h\") || \"\";\nconst path = queryString.get(\"p\") || \"\";\n\nwindow.onload = () => {\n    const parsedHost = URLCompressor.expand(host);\n    const parsedPath = URLCompressor.expand(path);\n\n    document.getElementById(\"url\").innerText =\n        `Target Site: http://${parsedHost}${parsedPath ? \"/\" + parsedPath : \"\"}`;\n};\n\nconst eventSource = new EventSource(\n    `/api/redirect?h=${host}${path.length ? \"&p=\" + path : \"\"}`\n);\neventSource.onmessage = (event) => {\n    console.log(`Wow! ${event.data}`);\n    if (event.data === \"redirect\") {\n        document.getElementById(\"redirect\").innerText =\n            \"Site is up! Redirect in 5 seconds...\";\n\n        const parsedHost = URLCompressor.expand(host);\n        const parsedPath = URLCompressor.expand(path);\n        console.log(\n            `http://${parsedHost}${parsedPath ? \"/\" + parsedPath : \"\"}`\n        );\n\n        setTimeout(() => {\n            window.location.href = `http://${parsedHost}${parsedPath ? \"/\" + parsedPath : \"\"}`;\n        }, 5000);\n    }\n};\n\n\n//# sourceURL=webpack://dynamic-portal/./lib/fallback.js?");

/***/ }),

/***/ "./lib/url-comp.js":
/*!*************************!*\
  !*** ./lib/url-comp.js ***!
  \*************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/* module decorator */ module = __webpack_require__.nmd(module);\n/*\n\"url-comp.js\"\nURLCompressor library Version 0.1.0\n\nCopyright (c) 2021 Hiroshi Tanigawa\nhttp://synapse.kyoto/\n\nThis program is distributed under MIT licence.\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n*/\n\nconst URLCompressor = (() => {\n    // refer https://qiita.com/weal/items/10122402adb61597f851\n\n    function getScalarArray(str) {\n        if (typeof str !== \"string\") {\n            return null;\n        } // if\n        const scalarArray = [];\n        for (let len = str.length, i = 0; i < len; i++) {\n            const c = str.charCodeAt(i);\n            if (c >= 0xd800 && c <= 0xdbff) {\n                // 前半サロゲートだった\n                if (i + 1 >= len) {\n                    // 後半サロゲートがなかった\n                    return null;\n                } // if\n                scalarArray.push(\n                    (((c & 0x3ff) + 0x40) << 10) | (str.charCodeAt(++i) & 0x3ff)\n                );\n            } else {\n                scalarArray.push(c);\n            } // if\n        } // for i\n        return scalarArray;\n    } // getScalarArray\n\n    function encodeUtf8(str) {\n        const scalarArray = getScalarArray(str);\n        if (scalarArray === null) {\n            return null;\n        } // if\n        let utf8str = \"\";\n        for (let len = scalarArray.length, i = 0; i < len; i++) {\n            const c = scalarArray[i];\n            if (c <= 0x7f) {\n                // 1 byte\n                utf8str += String.fromCharCode(c);\n            } else if (c <= 0x7ff) {\n                // 2 bytes\n                utf8str += String.fromCharCode(\n                    0xc0 | (c >>> 6),\n                    0x80 | (c & 0xbf)\n                );\n            } else if (c <= 0xffff) {\n                // 3 bytes\n                utf8str += String.fromCharCode(\n                    0xe0 | (c >>> 12),\n                    0x80 | ((c >>> 6) & 0xbf),\n                    0x80 | (c & 0xbf)\n                );\n            } else if (c <= 0x10ffff) {\n                // 4 bytes\n                utf8str += String.fromCharCode(\n                    0xf0 | (c >>> 18),\n                    0x80 | ((c >>> 12) & 0xbf),\n                    0x80 | ((c >>> 6) & 0xbf),\n                    0x80 | (c & 0xbf)\n                );\n            } else {\n                // 5バイト以上だった\n                return null;\n            } // if\n        } // for\n        return utf8str;\n    } // encodeUtf8\n\n    function decodeUtf8(str) {\n        if (typeof str !== \"string\") {\n            return null;\n        } // if\n        let utf16str = \"\";\n        for (let i = 0, len = str.length; i < len; i++) {\n            const c0 = str.charCodeAt(i);\n            if (c0 <= 0x7f) {\n                // 1 byte\n                utf16str += String.fromCharCode(c0);\n            } else if (c0 >= 0xc2 && c0 <= 0xdf) {\n                // 2 bytes\n                if (i + 1 >= len) {\n                    return null;\n                } // if\n                const c1 = str.charCodeAt(++i);\n                utf16str += String.fromCharCode(\n                    ((c0 & 0x1f) << 6) | (c1 & 0x3f)\n                );\n            } else if (c0 >= 0xe0 && c0 <= 0xef) {\n                // 3 bytes\n                if (i + 2 >= len) {\n                    return null;\n                } // if\n                const c1 = str.charCodeAt(++i);\n                const c2 = str.charCodeAt(++i);\n                utf16str += String.fromCharCode(\n                    ((c0 & 0xf) << 12) | ((c1 & 0x3f) << 6) | (c2 & 0x3f)\n                );\n            } else if (c0 >= 0xf0 && c0 <= 0xf4) {\n                // 4 bytes\n                if (i + 3 >= len) {\n                    return null;\n                } // if\n                const c1 = str.charCodeAt(++i);\n                const c2 = str.charCodeAt(++i);\n                const c3 = str.charCodeAt(++i);\n                utf16str += String.fromCharCode(\n                    0xd800 |\n                        ((((c0 & 0x7) << 8) |\n                            ((c1 & 0x3f) << 2) |\n                            ((c2 >>> 4) & 0x3)) -\n                            0x40),\n                    0xdc00 | ((c2 & 0xf) << 6) | (c3 & 0x3f)\n                );\n            } else {\n                // 不正なUTF8コード\n                return null;\n            } // if\n        } // for i\n        return utf16str;\n    } // decodeUtf8\n\n    const symbolNum = [258, 258, 130, 99];\n    const DIC = [256, 256, 128, 97];\n    const EOF = [257, 257, 129, 98];\n    const dictionarySize = 2048;\n    const totalOffset = 0.25;\n    const matchLimit = 1000;\n\n    const mode3EncodeTable = (() => {\n        const result = [];\n        let cnt = 0;\n        for (i = 0; i < 0x80; i++) {\n            if ((i < 0x20 && i !== 0x09 && i !== 0x0a) || i === 0x7f) {\n                result.push(null);\n            } else {\n                result.push(cnt++);\n            }\n        } // for i\n        return result;\n    })();\n\n    const mode3DecodeTable = (() => {\n        const result = [];\n        for (i = 0; i < mode3EncodeTable.length; i++) {\n            if (mode3EncodeTable[i] !== null) {\n                result.push(i);\n            } // if\n        } // for i\n        return result;\n    })(); // mode3DecodeTable\n\n    const base64UrlTable =\n        \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_\";\n\n    const base64UrlReverseTable = (() => {\n        const result = new Map();\n        for (let len = base64UrlTable.length, i = 0; i < len; i++) {\n            result.set(base64UrlTable[i], i);\n        } // for i\n        return result;\n    })(); // base64UrlReverseTable\n\n    function getRequiredBits(n) {\n        let m = 1;\n        let bits = 0;\n        while (n >= m) {\n            m <<= 1;\n            bits++;\n        } // while\n        return bits;\n    } // getRequiredBits\n\n    function getHuffmanTree(array, symbolNum) {\n        // シンボルをソートする\n        const symbolSortTable = [];\n        for (let i = 0; i < symbolNum; i++) {\n            symbolSortTable.push(null);\n            let j = i;\n            while (j > 0 && symbolSortTable[j - 1].count < array[i]) {\n                symbolSortTable[j] = symbolSortTable[j - 1];\n                j--;\n            } // while\n            symbolSortTable[j] = {\n                count: array[i],\n                symbol: i,\n                left: null,\n                right: null,\n            };\n        } // for i\n\n        // ハフマン木を作成する\n        while (symbolSortTable.length > 1) {\n            const newObj = {\n                count:\n                    symbolSortTable[symbolSortTable.length - 2].count +\n                    symbolSortTable[symbolSortTable.length - 1].count,\n                symbol: -1,\n                left: symbolSortTable[symbolSortTable.length - 2],\n                right: symbolSortTable[symbolSortTable.length - 1],\n            };\n            symbolSortTable.pop();\n            let i = symbolSortTable.length - 1;\n            while (i > 0 && symbolSortTable[i - 1].count < newObj.count) {\n                symbolSortTable[i] = symbolSortTable[i - 1];\n                i--;\n            } // while\n            symbolSortTable[i] = newObj;\n        } // while\n        return symbolSortTable[0];\n    } // getHuffmanTree\n\n    function getCodeTable(tree, symbolNum) {\n        const codeTable = [];\n        for (let i = 0; i < symbolNum; i++) {\n            codeTable.push(null);\n        } // for i\n        const codeBuf = {\n            buf: new Uint8Array((symbolNum + 7) >>> 3),\n            bitNum: 0,\n        };\n        const seekCode = (treeNode) => {\n            if (treeNode.symbol >= 0) {\n                // シンボルに到達した\n                const bitNum = codeBuf.bitNum;\n                const byteNum = (bitNum + 7) >>> 3;\n                const code = new Uint8Array(byteNum);\n                for (let i = 0; i < byteNum; i++) {\n                    code[i] = codeBuf.buf[i];\n                } // for i\n                codeTable[treeNode.symbol] = { code: code, bitNum: bitNum };\n            } else {\n                // 子ノードを探索\n                // 左の探索\n                const bitNum = codeBuf.bitNum;\n                codeBuf.buf[bitNum >>> 3] &= ~(1 << (7 - (bitNum % 8)));\n                codeBuf.bitNum++;\n                seekCode(treeNode.left);\n\n                // 右の探索\n                codeBuf.buf[bitNum >>> 3] |= 1 << (7 - (bitNum % 8));\n                seekCode(treeNode.right);\n                codeBuf.bitNum--;\n            } // if\n        }; // seekCode\n        seekCode(tree);\n        return codeTable;\n    } // getCodeTable\n\n    function compress(str, encode64 = true) {\n        let resultStr = \"\";\n        let byteBuf = 0;\n        let bitNum = 0;\n        const codeBits = encode64 ? 6 : 8;\n\n        // モードを返す\n        // MODE 0:strに256以上の文字コードが含まれていた\n        // MODE 1:strが255以下だけの文字コードで、128以上の文字コードが含まれていた\n        // MODE 2:strが127以下だけの文字コードだった\n        // MODE 3:strが127以下だけの文字コードで、0x00～0x08、0x0b～0x1f、0x7fを含まなかった\n        const getMode = (str) => {\n            const count = [];\n            for (let i = 0; i < 256; i++) {\n                count.push(0);\n            } // for i\n\n            for (let len = str.length, i = 0; i < len; i++) {\n                if (str.charCodeAt(i) >= 256) {\n                    return 0;\n                } // if\n                count[str.charCodeAt(i)]++;\n            } // for i\n\n            for (let i = 128; i < 256; i++) {\n                if (count[i] > 0) {\n                    return 1;\n                } // if\n            } // for i\n\n            for (let len = mode3EncodeTable.length, i = 0; i <= len; i++) {\n                if (mode3EncodeTable[i] === null && count[i] > 0) {\n                    return 2;\n                } // if\n            } // for i\n            return 3;\n        }; // getMode\n\n        const encodeInt = (intNum) => {\n            const buf = [3];\n            let i = intNum;\n            while (i !== 0) {\n                i--;\n                buf.push(i % 3);\n                i = Math.floor(i / 3);\n            } // while\n            const codeBuf = new Uint8Array((buf.length * 2 + 6) >>> 3);\n            let bitCnt = 0;\n            let byte = 0;\n            for (let i = buf.length - 1; i >= 0; i--) {\n                byte = (byte << 2) + buf[i];\n                bitCnt += 2;\n                if (bitCnt % 8 == 0) {\n                    codeBuf[(bitCnt >>> 3) - 1] = byte;\n                    byte = 0;\n                } // if\n            } // for i\n            if (bitCnt % 8 !== 0) {\n                const rem = 8 - (bitCnt % 8);\n                codeBuf[bitCnt >>> 3] = byte << rem;\n            } // if\n            return { codeBuf: codeBuf, bitCnt: bitCnt };\n        }; // encodeInt\n\n        const outputData = (codeBuf, bitCnt) => {\n            let bitPos = 0;\n            let bytePos = 0;\n            let remBits = bitCnt;\n            while (remBits > 0) {\n                byteBuf =\n                    (byteBuf << 1) + ((codeBuf[bytePos] >> (7 - bitPos)) & 1);\n                if (++bitNum === codeBits) {\n                    resultStr += encode64\n                        ? base64UrlTable[byteBuf]\n                        : String.fromCharCode(byteBuf);\n                    byteBuf = 0;\n                    bitNum = 0;\n                } // if\n                if (++bitPos == 8) {\n                    bitPos = 0;\n                    bytePos++;\n                } // if\n                remBits--;\n            } // while\n        }; // outputData\n\n        const outputMode = (mode) => {\n            const tempArray = new Uint8Array(1);\n            tempArray[0] = mode << 6;\n            outputData(tempArray, 2);\n        }; // outputMode\n\n        // body of compress\n        if (typeof str !== \"string\") {\n            return null;\n        } // if\n\n        const mode = getMode(str); // モードの取得\n        const _symbolNum = symbolNum[mode]; // シンボル数の取得\n        const _DIC = DIC[mode]; // スライド辞書用シンボルの取得\n        const _EOF = EOF[mode]; // データ終端用シンボルの取得\n\n        let strToCompress;\n        if (mode === 0) {\n            // モード0なら、UTF8にエンコード\n            strToCompress = encodeUtf8(str);\n            if (strToCompress === null) {\n                return null; // UTF8のエンコードに失敗した\n            } // if\n        } else if (mode === 3) {\n            // モード3なら97文字に圧縮\n            const encodeTable = mode3EncodeTable;\n            strToCompress = \"\";\n            for (let len = str.length, i = 0; i < len; i++) {\n                strToCompress += String.fromCharCode(\n                    encodeTable[str.charCodeAt(i)]\n                );\n            } // for i\n        } else {\n            strToCompress = str;\n        } // if\n\n        // symbolTotalTableの初期化\n        let symbolTotalTable = [];\n        for (let i = 0; i < _symbolNum; i++) {\n            symbolTotalTable.push(totalOffset);\n        } // for i\n\n        // モードの書き出し\n        outputMode(mode);\n\n        // スライド辞書関係の初期化\n        const lastIndex = [];\n        for (let i = 0; i < 256; i++) {\n            lastIndex.push(null);\n        } // i\n        const prevIndex = [];\n\n        // メインループ\n        let tree;\n        let codeTable;\n        let i = 0;\n        let symbolCnt = 0;\n        let len = strToCompress.length;\n        while (true) {\n            if (symbolCnt < 256 || symbolCnt % 8 === 0) {\n                tree = getHuffmanTree(symbolTotalTable, _symbolNum);\n                codeTable = getCodeTable(tree, _symbolNum);\n            } // if\n            if (i >= len) {\n                break;\n            } // if\n            let code = strToCompress.charCodeAt(i);\n            let maxMatch = 0;\n            let matchIndex = 0;\n            if (i > 0) {\n                // スライド辞書検索\n                let index = lastIndex[code];\n                while (index !== null && i - index <= dictionarySize) {\n                    let match = 1;\n                    while (\n                        i + match - 1 < strToCompress.length &&\n                        strToCompress[i + match] ===\n                            strToCompress[index + match]\n                    ) {\n                        match++;\n                        if (match >= matchLimit) {\n                            break;\n                        } // if\n                    } // while\n                    if (match > maxMatch) {\n                        maxMatch = match;\n                        matchIndex = index;\n                        if (maxMatch >= matchLimit) {\n                            break;\n                        } // if\n                    } // if\n                    index = prevIndex[index];\n                } // while\n            } // if\n            if (maxMatch >= 3) {\n                code = _DIC;\n            } // if\n            outputData(codeTable[code].code, codeTable[code].bitNum);\n            let step = 1;\n            if (code === _DIC) {\n                // スライド辞書がヒットした\n                const encResult = encodeInt(maxMatch - 3);\n                outputData(encResult.codeBuf, encResult.bitCnt);\n                const offset = i - matchIndex - 1;\n                const bits = getRequiredBits(\n                    Math.min(i - 1, dictionarySize - 1)\n                );\n                const offsetArray = new Uint8Array(2);\n                if (bits <= 8) {\n                    offsetArray[0] = offset << (8 - bits);\n                } else {\n                    offsetArray[0] = offset >> (bits - 8);\n                    offsetArray[1] = (offset << (16 - bits)) & 0xff;\n                } // if\n                outputData(offsetArray, bits);\n                step = maxMatch;\n            } // if\n            for (let j = 0; j < step; j++) {\n                prevIndex.push(lastIndex[strToCompress.charCodeAt(i)]);\n                lastIndex[strToCompress.charCodeAt(i)] = i;\n                i++;\n            } // for j\n            symbolCnt++;\n            symbolTotalTable[code]++;\n        } // while\n\n        if (bitNum > 0) {\n            // 未出力のコードが残っていた時の処理\n            byteBuf =\n                (byteBuf << (codeBits - bitNum)) +\n                (codeTable[_EOF].code[0] >> (bitNum + 8 - codeBits));\n            resultStr += encode64\n                ? base64UrlTable[byteBuf]\n                : String.fromCharCode(byteBuf);\n        } // if\n\n        return resultStr;\n    } // compress\n\n    function expand(str, decode64 = true) {\n        let bytePos;\n        let bitPos;\n        let code;\n        const codeBuf = new Uint8Array(str.length);\n        const codeBits = decode64 ? 6 : 8;\n\n        const readBit = () => {\n            const bit = (code >> (codeBits - bitPos - 1)) & 1;\n            if (++bitPos === codeBits) {\n                bitPos = 0;\n                bytePos++;\n                if (bytePos < len) {\n                    code = codeBuf[bytePos];\n                } // if\n            } // if\n            return bit;\n        }; // readBit\n\n        const decodeInt = () => {\n            let w = 0;\n            let decodedNum = 0;\n            do {\n                if (bytePos >= codeBuf.length) {\n                    return -1;\n                } // if\n                w = readBit();\n                if (bytePos >= codeBuf.length) {\n                    return -1;\n                } // if\n                w = (w << 1) + readBit();\n                if (w < 3) {\n                    decodedNum = decodedNum * 3 + w + 1;\n                } // if\n            } while (w < 3);\n            return decodedNum;\n        }; // decodeInt\n\n        const getMode = () => {\n            let mode = readBit();\n            mode = (mode << 1) + readBit();\n            return mode;\n        }; // getMode\n\n        // body of decode\n        if (typeof str !== \"string\" || str.length === 0) {\n            return null;\n        } // if\n\n        for (let len = str.length, i = 0; i < len; i++) {\n            let code;\n            if (decode64) {\n                code = base64UrlReverseTable.get(str[i]);\n                if (code === undefined) {\n                    return null;\n                } // if\n            } else {\n                code = str.charCodeAt(i);\n                if (code >= 0x100) {\n                    return null;\n                } // if\n            } // if\n            codeBuf[i] = code;\n        } // for i\n\n        bytePos = 0;\n        bitPos = 0;\n        code = codeBuf[0];\n\n        const mode = getMode(); // modeの取得\n        const _symbolNum = symbolNum[mode]; // シンボルの種類の取得\n        const _DIC = DIC[mode]; // スライド辞書用シンボルの取得\n        const _EOF = EOF[mode]; // データ終端用のシンボルの取得\n\n        let symbolTotalTable = [];\n        for (let i = 0; i < _symbolNum; i++) {\n            symbolTotalTable.push(totalOffset);\n        } // for i\n\n        let expandedStr = \"\";\n        let tree = getHuffmanTree(symbolTotalTable, _symbolNum);\n        let node = tree;\n\n        let symbolCnt = 0;\n        const len = codeBuf.length;\n        let index = 0;\n        while (bytePos < len) {\n            node = readBit() ? node.right : node.left;\n            if (node.symbol >= 0) {\n                //シンボルに達した\n                if (node.symbol === _EOF) {\n                    break;\n                } else if (node.symbol === _DIC) {\n                    // スライド辞書がヒットした\n                    const decoded = decodeInt();\n                    if (decoded < 0) {\n                        return null;\n                    } // if\n                    const matchLen = decoded + 3;\n                    if (matchLen > matchLimit) {\n                        return null;\n                    } // if\n                    let offset = 0;\n                    const bits = getRequiredBits(\n                        Math.min(index - 1, dictionarySize - 1)\n                    );\n                    for (let i = 0; i < bits; i++) {\n                        if (bytePos >= len) {\n                            return null;\n                        } // if\n                        offset = (offset << 1) + readBit();\n                    } // for i\n                    if (offset >= index) {\n                        return null;\n                    } // if\n                    for (let i = 0; i < matchLen; i++) {\n                        expandedStr += expandedStr[index - offset - 1 + i];\n                    } // for i\n                    index += matchLen;\n                } else {\n                    expandedStr += String.fromCharCode(node.symbol);\n                    index++;\n                } //if\n                symbolTotalTable[node.symbol]++;\n                symbolCnt++;\n                if (symbolCnt < 256 || symbolCnt % 8 === 0) {\n                    tree = getHuffmanTree(symbolTotalTable, _symbolNum);\n                } // if\n                node = tree;\n            } // if\n        } // while\n\n        if (mode === 0) {\n            // モード0ならUTF8をUTF16にデコード\n            expandedStr = decodeUtf8(expandedStr);\n            if (expandedStr === null) {\n                return null;\n            } // if\n        } else if (mode === 3) {\n            str = \"\";\n            for (let len = expandedStr.length, i = 0; i < len; i++) {\n                str += String.fromCharCode(\n                    mode3DecodeTable[expandedStr.charCodeAt(i)]\n                );\n            } // for i\n            expandedStr = str;\n        } // if\n        return expandedStr;\n    } // expand\n\n    return {\n        compress: compress,\n        expand: expand,\n        encodeUtf8: encodeUtf8,\n        decodeUtf8: decodeUtf8,\n    };\n})(); // URLCompressor\n\n// for Node.js\nif ( true && module != null) {\n    module.exports = URLCompressor;\n} // if\n\n\n//# sourceURL=webpack://dynamic-portal/./lib/url-comp.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/node module decorator */
/******/ 	(() => {
/******/ 		__webpack_require__.nmd = (module) => {
/******/ 			module.paths = [];
/******/ 			if (!module.children) module.children = [];
/******/ 			return module;
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./lib/fallback.js");
/******/ 	
/******/ })()
;